#!/usr/bin/env bash

#The MIT License (MIT) {{{
#
#Copyright (c) 2013 rcmdnk
#
#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#}}}

# Default variables
rdir=0
force=1
confirm=0
tbox=${TRASHBOX:-~/.Trash}
tlist=${TRASHLIST:-~/.trashlist}
maxboxsize=${MAXTRASHBOXSIZE:-1024}
maxsize=${MAXTRASHSIZE:-102}
clean=0
clean_full=0
list=0
back=0
verbose=0

# Help
HELP="
Usage: trash [-rficClbv] [-v <verbose level>] [-t <trash_box>] <file/directory>

Arguments:
   -r              Remove directory (default: $rdir)
   -f              Remove w/o confirmation (default: $force)
   -i              Remove w/ confirmation (default: $confirm)
   -t <trash_box>  Use given trash box instead of $tbox
   -c              Clean up trash box (make it less than MAXTRASHBOXSIZE)
   -C              Clean up trash box (make it empty)
   -l              List up deleted files/directories in the trash box
   -b              Restore (turn Back) the file from the trash box
   -v <level>      Verbose level for list view
                   0 : Only original location (default).
                   1 : With Delete date-time (yyyymdd-hh:mm).
                   2 : With Current location (in the trash box).
   -h              Print this HELP and exit

To use trash, please specify following variables
in .bashrc or your setting file like (these rh values are default):

At restore mode, you can use following keys (based on vim move):
 <n>   : (any numb), set n for move
 j     : n-down (if n is not defined, 1 down)
 ^D    : Half page down
 ^F    : Page down
 k     : n-up   (if n is not defined, 1 up)
 ^U    : Half page up
 ^B    : Page up
 gg    : Go to top    (if n is defined, go to n)
 G     : Go to bottom (if n is defined, go to n)
 d     : Delete
 s     : Show details
 Enter : Select to bring back to the original place, and quit
 h     : Select to copy it to current directory (here), and quit
 q     : Quit

export TRASHLIST=~/.trashlist # Where trash list is written
export TRASHBOX=~/.Trash # Where trash will be moved in
                         # (.Trash is Mac's trash box)
export MAXTRASHBOXSIZE=1024 # Max trash box size in MB
                            # Used for clean up
export MAXTRASHSIZE=\`echo \$MAXTRASHBOXSIZE \"*\" 0.1|bc -l|cut -d. -f1\`
    # Trashes larger than MAXTRASHBOXSIZE will be removed by 'rm' directly
"

# Get option
while getopts rfit:cClbv:h OPT;do
  case $OPT in
    "r" ) rdir=1 ;;
    "f" ) force=1;confirm=0 ;;
    "i" ) confirm=1;force=1 ;;
    "t" ) tbox="$OPTARG" ;;
    "c" ) clean=1 ;;
    "C" ) clean_full=1 ;;
    "l" ) list=1 ;;
    "b" ) back=1 ;;
    "v" ) verbose=$OPTARG ;;
    "h" ) echo "$HELP" 1>&2;exit 0;;
    * ) echo "$OPT is not expected."
        echo "$HELP" 1>&2;exit 1;;
  esac
done

# nth show helper function
function nth () {
  if [ $1 -eq 1 ];then
    echo 1st
  elif [ $1 -eq 2 ];then
    echo 2nd
  elif [ $1 -eq 3 ];then
    echo 3rd
  else
    echo ${1}th
  fi
}


shift $(($OPTIND - 1))

# Use more one depth directory to distinguish from other trash
# (especially for Mac's ~/.Trash case)
mytbox="$tbox/my_trash_box"

# Clean up the trash box
if [ $clean_full -eq 1 ];then
  rm -rf "$mytbox"
  rm -rf "$tlist"
  touch "$tlist"
  exit 0
elif [ $clean -eq 1 ];then
  if [ ! -d ${mytbox} ];then
    exit 0
  fi
  # Clean up trash box
  touch "$tlist"
  while [ 1 ];do
    trash_box_size=`du -ms ${mytbox} |awk '{print $1}'`
    if [ ${trash_box_size} -gt ${maxboxsize} ];then
      delete_dir=`ls -tr ${TRASHBOX} | head -1`
      rm -rf "${mytbox}/${delete_dir}"
      sed -i.bak "\!${mybox}/${delete_dir}!d" "$tlist"
      rm -f "$tlist.bak"
    else
      break
    fi
  done
  # Clean up trash list
  while read line;do
    orig_ifs=$IFS
    IFS=","
    tinfo=(${line})
    IFS=$orig_ifs
    trash_name_short=${tinfo[2]}
    trash_name=$(sh -c "echo $trash_name_short") # Expand ~
    if [ ! -e "$trash_name" ];then
      sed -i.bak "\!${trash_name_short}\$!d" "$tlist"
      rm -f "$tlist.bak"
    fi
  done < "$tlist"
  exit 0
fi

# List up deleted files/directories
if [ $list -eq 1 ];then
  # List up trashes
  touch "$tlist"
  i=1
  ntrash=$(cat "$tlist"|wc -l);ntrash=$(echo $ntrash)
  if [ $ntrash -eq 0 ];then
    echo There is no trash
    exit 0
  fi
  nwidth=${#ntrash}
  while read line;do
    orig_ifs=$IFS
    IFS=","
    t=($line)
    IFS=$orig_ifs
    if [ $verbose -ge 2 ];then
      printf "%${nwidth}d %s %s %s\n" $i "${t[0]}" "${t[1]}" "${t[2]}"
    elif [ $verbose -eq 1 ];then
      printf "%${nwidth}d %s %s \n" $i "${t[0]}" "${t[1]}"
    else
      printf "%${nwidth}d %s\n" $i "${t[1]}"
    fi
    ((i++))
  done < "$tlist"
  exit 0
fi

# Bring back a trash
if [ $back -eq 1 ];then

  function get_trash_list () {
    touch "$tlist"
    ntrash=$(cat "$tlist"|wc -l);ntrash=$(echo $ntrash)
    if [ $ntrash -eq 0 ];then
      clear
      echo There is no trash
      sleep 3
      exit 0
    fi
    nwidth=${#ntrash}
    orig_ifs=$IFS
    IFS=$'\n'
    trash_list=($(cat "$tlist"))
    IFS=$orig_ifs
  }

  function set_header () {
    # Set variables
    header=" $ntrash trashes in total
 vim like move (j/k/gg/G etc...)
 d(delete), s(show details), q(quit)
 Enter: Select to bring back to the original place, and quit
 h: Select to copy it to current directory, and quit
"

    ext_row=$(echo "$header"|wc -l)
    lines=$(tput lines)
    cols=$(tput cols)
    max_show=$ntrash
    if [ $ntrash -gt $((lines-ext_row)) ];then
      max_show=$((lines-ext_row))
    fi
  }

  function printline () {
    local orig_ifs=$IFS
    IFS=","
    local tinfo=(${trash_list[$3]})
    IFS=$orig_ifs
    local trash_show=${tinfo[1]}
    if [ ${#trash_show} -gt $((cols-nwidth-2)) ];then
      trash_show="${trash_show: $((${#trash_show}-cols+nwidth+2))}"
    fi
    tput cup $(($2)) 0
    if [ $1 -eq 1 ];then
      printf "\e[7m%${nwidth}d: ${trash_show}\e[m" $(($3+1))
    else
      printf "%${nwidth}d: ${trash_show}" $(($3+1))
    fi
    tput cup $(($2)) 0
  } # }}}

  function printall () {
    local offset=0
    local select=0
    if [ $# -gt 0 ];then
      offset=$1
      if [ $# -gt 1 ];then
        select=$2
      fi
    fi
    clear
    # Header
    echo "$header"
    local i
    for ((i=0; i<max_show; i++));do
      if [ $((i+offset)) -eq $select ];then
        printline 1 $((i+ext_row)) $((i+offset))
      else
        printline 0 $((i+ext_row)) $((i+offset))
      fi
    done
  }

  function delete_trash () {
    local orig_ifs=$IFS
    IFS=","
    local tinfo=(${trash_list[$1]})
    IFS=$orig_ifs
    local origin_name_short=${tinfo[1]}
    local trash_name_short=${tinfo[2]}
    local origin_name=$(sh -c "echo $origin_name_short") # Expand ~
    local trash_name=$(sh -c "echo $trash_name_short") # Expand ~
    if [ "$origin_name" = "" ] || [ "$trash_name" = "" ];then
      clear
      echo "$tlist might be corrupted"
      echo "Check $(nth $(($1+1))) trash information in $tlist"
      sleep 3
      exit 1
    elif [ ! -e "$trash_name" ];then
      clear
      echo "Trash of $origin_name_short ($trash_name_short) does not exist in $tbox, remove from the list"
      sleep 3
    fi
    rm -rf "$trash_name"
    sed -i.bak "\!${trash_name_short}\$!d" "$tlist"
    rm -f "$tlist.bak"
  }

  function trash_exit () {
    # clear after selection
    clear

    # Show cursor
    tput cnorm 2>/dev/null || tput vs 2>/dev/null

    # Restore display
    tput rmcup 2>/dev/null || tput te 2>/dev/null

    # Enable echo input
    stty echo
  }

  # Set trap
  trap trash_exit 0

  # Hide cursor
  tput civis 2>/dev/null || tput vi 2>/dev/null

  # Save current display
  tput smcup 2>/dev/null || tput ti 2>/dev/null

  # Hide any input (need to cleanup a print, especially when re-draw with printall.)
  stty -echo

  # First view
  get_trash_list
  set_header
  printall

  # Select trash
  n=0
  n_offset=0
  cursor_r=$ext_row
  g=0
  n_move=0
  here=0
  tput cup $cursor_r 0

  while : ;do
    read -s -n 1 c
    case $c in
      j|$'\x04'|$'\x06' ) # j/^D/^F
        if [ $c = $'\x04' ];then
          n_move=$((max_show/2))
        elif [ $c = $'\x06' ];then
          n_move=$((max_show))
        elif [ $n_move -eq 0 ];then
          n_move=1
        fi
        all=0
        printline 0 $cursor_r $n
        for ((i=0; i<n_move; i++));do
          if [ $n -eq $((ntrash-1)) ];then
            :
          elif [ $cursor_r -eq $((lines-1)) ];then
            ((n_offset++));((n++))
            all=1
          else
            ((cursor_r++));((n++))
          fi
        done
        if [ $all -eq 1 ];then
          printall $n_offset $n
        else
          printline 1 $cursor_r $n
        fi
        g=0
        n_move=0
        continue
        ;;
      k|$'\x15'|$'\x02' ) # k/^U/^B
        if [ $c = $'\x15' ];then
          n_move=$((max_show/2))
        elif [ $c = $'\x02' ];then
          n_move=$((max_show))
        elif [ $n_move -eq 0 ];then
          n_move=1
        fi
        all=0
        printline 0 $((cursor_r)) $n
        for ((i=0; i<n_move; i++));do
          if [ $cursor_r -ne $ext_row ];then
            ((cursor_r--));((n--))
          elif [ $n_offset -gt 0 ];then
            ((n_offset--));((n--))
            all=1
          else
            :
          fi
        done
        if [ $all -eq 1 ];then
          printall $n_offset $n
        else
          printline 1 $cursor_r $n
        fi
        g=0
        n_move=0
        continue
        ;;
      g )
        if [ $g -eq 0 ];then
          g=1
          continue
        fi

        if [ $n_move -eq 0 ];then
          n=0
          n_offset=0
          cursor_r="$ext_row"
        elif [ $n_move -gt $ntrash ];then
          :
        elif [ $n_move -le $n_offset ];then
          n=$((n_move-1))
          n_offset=$n
          cursor_r=$ext_row
        elif [ $((n_move)) -gt $((n_offset+max_show)) ];then
          n=$((n_move-1))
          n_offset=$((n-max_show+1))
          cursor_r=$((lines-1))
        else
          n=$((n_move-1))
          cursor_r=$((ext_row+n-n_offset))
        fi
        printall $n_offset $n
        n_move=0
        g=0
        continue
        ;;
      G )
        if [ $n_move -eq 0 ];then
          n=$((ntrash-1))
          if [ $n -ge $max_show ];then
            n_offset=$((ntrash-max_show))
            cursor_r=$((lines-1))
          else
            n_offset=0
            cursor_r=$((ext_row+n))
          fi
        elif [ $n_move -gt $ntrash ];then
          :
        elif [ $n_move -le $n_offset ];then
          n=$((n_move-1))
          n_offset=$n
          cursor_r=$ext_row
        elif [ $n_move -gt $((n_offset+max_show)) ];then
          n=$((n_move-1))
          n_offset=$((n-max_show+1))
          cursor_r=$((lines-1))
        else
          n=$((n_move-1))
          cursor_r=$((ext_row+n-n_offset))
        fi
        printall $n_offset $n
        n_move=0
        continue
        ;;
      d )
        # Delete Trash
        delete_trash $n

        # Re-read trash list
        get_trash_list

        # Check a number of trashes
        if [ $n -eq $ntrash ];then
          if [ $n_offset -gt 0 ];then
            ((n_offset--));((n--))
          else
            ((cursor_r--));((n--))
          fi
        fi

        # Print
        set_header
        printall $n_offset $n
        ;;
      s )
        # Show Detail
        orig_ifs=$IFS
        IFS=","
        tinfo=(${trash_list[$1]})
        IFS=$orig_ifs
        origin_name_short=${tinfo[1]}
        trash_name_short=${tinfo[2]}

        clear
        echo $(nth $((n+1))) trash:
        echo Original file    : $origin_name_short
        echo File in trash box: $trash_name_short
        sleep 3

        printall
        ;;
      q|$'\x1b' ) exit 0;;
      ""  ) break;;
      h ) here=1;break;;
      [0-9])
        if [ $n_move -gt 0 ];then
          n_move="$n_move""$c"
        else
          n_move=$c
        fi
        continue
        ;;
      * ) continue;;
    esac
  done

  # Get trash information
  orig_ifs=$IFS
  IFS=","
  tinfo=(${trash_list[$n]})
  IFS=$orig_ifs
  origin_name_short=${tinfo[1]}
  trash_name_short=${tinfo[2]}
  origin_name=$(sh -c "echo $origin_name_short") # Expand ~
  trash_name=$(sh -c "echo $trash_name_short") # Expand ~

  # Check trash information
  if [ "$origin_name" = "" ] || [ "$trash_name" = "" ];then
    clear
    echo "$tlist might be corrupted"
    echo "Check $(nth $(($1+1))) trash information in $tlist"
    sleep 3
    exit 1
  elif [ ! -e "$trash_name" ];then
    clear
    echo "$trash_name_short doesn't exist, remove from the list"
    sed -i.bak "\!${trash_name_short}\$!d" "$tlist"
    rm -f "$tlist.bak"
    sleep 3
    exit 1
  fi

  # Bring back
  target="$origin_name"
  if [ $here -eq 1 ];then
    target=$(basename $origin_name)
  fi
  if [ $confirm -eq 1 ];then
    if [ -e "$target" ];then
      clear
      echo -n "$origin_name_short exists. Do you want to overwrite from trash box? : "
      tput cnorm 2>/dev/null || tput vs 2>/dev/null
      stty echo
      read yes
      if ! [[ "$yes" =~ ^[yY] ]];then
        exit 0
      fi
    fi
  fi
  if [ $here -eq 1 ];then
    cp "$trash_name" "$target"
    echo ${target} was copied from ${trash_name_short}
  else
    mv "$trash_name" "$target"
    echo ${target} was restored from ${trash_name_short}
    sed -i.bak "\!${trash_name_short}\$!d" "$tlist"
    rm -f "$tlist.bak"
  fi
  exit 0
fi

# Check arguments
if [ "$#" -lt 1 ];then
  echo "No file/directory is given." 1>&2;
  echo "$HELP" 1>&2;
  exit 1
fi

# Set rm flags
if [ $force -eq 1 ];then
  rmflag="-f"
else
  rmflag="-i"
fi
if [ $rdir -eq 1 ];then
  rmflag="$rmflag -r"
fi

# Set today's trash box
tboxtoday="$mytbox/`date +%Y%m%d`"
if [ ! -d "$tboxtoday" ];then
  mkdir -p "$tboxtoday"
fi

# Iterate on arguments
while [ "$#" -gt 0 ];do
  if [ ! -e "$1" ];then
    echo $1: No such file or directory
    if [ $force -ne 1 ];then
      exit 1
    fi
    shift
    continue
  fi
  trash_size=`du -ms "${1}" |awk '{print $1}'`
  if [ ${trash_size} -gt ${maxsize} ];then
    echo $1 is larger than $maxsize MB, then I delete it directly
    rm $rmflag "$1"
    shift
    continue
  fi

  if [ -d "$1" ] && [ $rdir -ne 1 ];then
    echo $1: is a directory, use "-r" for directory
    shift
    continue
  fi

  if [ $confirm -eq 1 ];then
    echo -n "remove ${1}? "
    read yes
    if ! [[ "$yes" =~ ^[yY] ]];then
      shift
      continue
    fi
  fi

  origin_name=`echo $(cd "$(dirname $1)";pwd -P)/$(basename $1)`
  name=`echo $1 | sed -e "s|/$||" | sed -e "s|.*/||"`
  trash_head=${tboxtoday}/${name}
  trash_name=${trash_head}
  i=1
  while true;do
    if [ -e ${trash_name} ];then
      trash_name=${trash_head}.${i}
      i=`expr ${i} + 1`
    else
      break
    fi
  done

  mv "$origin_name" "$trash_name"
  origin_name_short="${origin_name/#$HOME/~}"
  trash_name_short="${trash_name/#$HOME/~}"
  echo $origin_name_short was moved to $trash_name_short
  mv "$tlist" "$tlist.bak"
  echo "`date +%Y%m%d-%H:%M`,$origin_name_short,$trash_name_short" > "$tlist"
  cat "$tlist.bak" >> "$tlist"
  rm -f "$tlist.bak"
  shift
done
