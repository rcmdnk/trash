#!/usr/bin/env bash

#The MIT License (MIT) {{{
#
#Copyright (c) 2013 rcmdnk
#
#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#}}}

# source sentaku
. sentaku -n

# Default variables
_SENTAKU_INPUT_FILE=${TRASHLIST:-$HOME/.trashlist}
_SENTAKU_MAX=10000000
_SENTAKU_SEPARATOR=$'\n'

_sf_initialize_user () { # {{{
  # Default variables
  rdir=0
  force=1
  confirm=0
  tbox=${TRASHBOX:-$HOME/.Trash}
  # Use more one depth directory to distinguish from other trash
  # (especially for Mac's ~/.Trash case)
  mytbox="$tbox/my_trash_box"
  maxboxsize=${MAXTRASHBOXSIZE:-1024} #MB
  maxsize=${MAXTRASHSIZE:-102} #MB
  clean=0
  clean_full=0
  list=0
  back=0
  verbose=0
  here=0
  trashes=()

  # Help
  _s_help="
Usage: trash [-rficClbv] [-v <verbose level>] [-t <trash_box>] <file/directory>

Arguments:
   -r              Remove directory (default: $rdir)
   -f              Remove w/o confirmation (default: $force)
   -i              Remove w/ confirmation (default: $confirm)
   -t <trash_box>  Use given trash box instead of $tbox
   -c              Clean up trash box (make it less than MAXTRASHBOXSIZE)
   -C              Clean up trash box (make it empty)
   -l              List up deleted files/directories in the trash box
   -b              Restore (turn Back) the file from the trash box
   -v <level>      Verbose level for list view
                   0 : Only original location (default).
                   1 : With Delete date-time (yyyymdd-hh:mm).
                   2 : With Current location (in the trash box).
   -h              Print this HELP and exit

To use trash, please specify following variables
in .bashrc or your setting file like (these rh values are default):

At restore mode, you can use vim like move keys like j(up)/k(down)/gg(top)/G(bottom).

In addition, following keys are available at restore mode:

 d     : Delete
 s     : Show details
 Enter : Select to bring back to the original place, and quit
 h     : Select to copy it to current directory (here), and quit
 q     : Quit

export TRASHLIST=~/.trashlist # Where trash list is written
export TRASHBOX=~/.Trash # Where trash will be moved in
                         # (.Trash is Mac's trash box)
export MAXTRASHBOXSIZE=1024 # Max trash box size in MB
                            # Used for clean up
export MAXTRASHSIZE=\`echo \$MAXTRASHBOXSIZE \"*\" 0.1|bc -l|cut -d. -f1\`
    # Trashes larger than MAXTRASHBOXSIZE will be removed by 'rm' directly
"

# }}}

_sf_check_args () { # {{{
  _s_continue=0
  while getopts rfit:cClbv:h OPT;do
    case $OPT in
      "r" ) rdir=1 ;;
      "f" ) force=1;confirm=0 ;;
      "i" ) confirm=1;force=1 ;;
      "t" ) tbox="$OPTARG" ;;
      "c" ) clean_full=0;clean=1;;
      "C" ) clean_full=1;clean=1;;
      "l" ) list=1 ;;
      "b" ) back=1 ;;
      "v" ) verbose=$OPTARG ;;
      "h" ) echo "$_s_help" >/dev/tty;return 0;;
      * ) echo "$_s_help" >/dev/tty;return 1;;
    esac
  done
  shift $(($OPTIND - 1))
  trashes=("$@")

  if [ $clean -eq 1 ];then
    cleanup $clean_full
    return $?
  fi

  if [ $list -eq 1 ];then
    listup
    return $?
  fi

  if [ $back -eq 1 ];then
    _s_continue=1
    return 0
  fi

} # }}}


cleanup () { # Clean up the trash box {{{
  # Cleanup fully
  if [ $1 -eq 1 ];then
    rm -rf "$mytbox"
    rm -rf "$_s_file"
    touch "$_s_file"
    return 0
  fi

  # Check if trash box exists or not
  if [ ! -d ${mytbox} ];then
    return 0
  fi

  # Clean up trash box
  touch "$_s_file"
  while [ 1 ];do
    trash_box_size=`du -ms ${mytbox} |awk '{print $1}'`
    if [ ${trash_box_size} -gt ${maxboxsize} ];then
      delete_dir=`ls -tr ${tbox} | head -1`
      rm -rf "${mytbox}/${delete_dir}"
      sed -i.bak "\!${mybox}/${delete_dir}!d" "$_s_file"
      rm -f "${_s_file}.bak"
    else
      break
    fi
  done

  # Clean up trash list
  while read line;do
    orig_ifs=$IFS
    IFS=","
    tinfo=(${line})
    IFS=$orig_ifs
    trash_name_short=${tinfo[2]}
    trash_name=$(sh -c "echo $trash_name_short") # Expand ~
    if [ ! -e "$trash_name" ];then
      sed -i.bak "\!${trash_name_short}\$!d" "$_s_file"
      rm -f "$_s_file.bak"
    fi
  done < "$_s_file"
  return 0
} # }}}

listup () { # List up deleted files/directories {{{
  touch "$_s_file"
  ntrash=$(cat "$_s_file"|wc -l);ntrash=$(echo $ntrash)
  if [ $ntrash -eq 0 ];then
    echo There is no trash
    return 0
  fi
  if type tac >& /dev/null;then
    reverse=tac
  elif tail --version 2>/dev/null|grep -q GNU;then
    reverse='tail -r'
  else
    reverse='cat'
  fi
  nwidth=${#ntrash}
  local i=0
  $reverse "$_s_file"|while read line;do
    orig_ifs=$IFS
    IFS=","
    t=($line)
    IFS=$orig_ifs
    if [ $verbose -ge 2 ];then
      printf "%${nwidth}d %s %s %s\n" $i "${t[0]}" "${t[1]}" "${t[2]}"
    elif [ $verbose -eq 1 ];then
      printf "%${nwidth}d %s %s \n" $i "${t[0]}" "${t[1]}"
    else
      printf "%${nwidth}d %s\n" $i "${t[1]}"
    fi
    ((i++))
  done
} # }}}

_sf_set_header () { # {{{
  _s_header=""
  if [ $_s_noheader = 1 -o $_s_lines -lt 10 ];then
    return
  fi
  if [ $_s_cols -ge 62 ];then
    _s_header=" $_s_n trashes in total
 vim like move (j/k/gg/G etc...)
 d(delete), s(show details), q(quit)
 Enter: Select to bring back to the original place, and quit
 h: Select to copy it here (current directory), and quit"
  elif [ $_s_cols -ge 40 ];then
    _s_header=" $_s_n trashes in total
 vim like move (j/k/gg/G etc...)
 d(delete), s(show details), q(quit)
 Enter: Bring it back
 h: Copy it here (current directory)"
  fi
}  # }}}

_sf_show () { # _sf_show [is_last [n_show]] {{{
  local is_last=1
  local n_show=${2:-$_s_cols}

  local orig_ifs=$IFS
  IFS=","
  local tinfo=($_s_show)
  IFS=$orig_ifs
  local day=${tinfo[0]}
  local trash=${tinfo[1]}
  local dest=${tinfo[2]}

  if [ $verbose -ge 1 ];then
    n_show=$((n_show-${#day}-1))
  fi
  if [ ${#trash} -gt $n_show ];then
    if [ "x$ZSH_VERSION" != "x" ];then
      trash="${trash[$((${#trash}-$n_show)),-1]}"
    else
      trash="${trash: $((${#trash}-$n_show))}"
    fi
  fi
  _s_show="$trash"
  if [ $verbose -ge 1 ];then
    _s_show="$day $trash"
  fi
} # }}}

_sf_delete () { # {{{
  local n=$_s_current_n
  local orig_ifs=$IFS
  IFS=","
  local tinfo=(${_s_inputs[$n]})
  IFS=$orig_ifs
  local origin_name_short=${tinfo[1]}
  local trash_name_short=${tinfo[2]}
  local origin_name=$(sh -c "echo $origin_name_short") # Expand ~
  local trash_name=$(sh -c "echo $trash_name_short") # Expand ~
  if [ "$origin_name" = "" ] || [ "$trash_name" = "" ];then
    _sf_echo "$tlist might be corrupted
Check $(_sf_nth $(($1+1))) trash information in $tlist"
    _sf_quit 1
    return 1
  elif [ ! -e "$trash_name" ];then
    _sf_echo "Trash of $origin_name_short ($trash_name_short) does not exist in $tbox, remove from the list"
  fi
  rm -rf "$trash_name"

  rm -f "$_s_file"
  local i
  for ((i=0; i<$_s_n; i++));do
    [ $i -ne $n ] && printf "%s$_s_s_push" "${_s_inputs[$i]}" >> "$_s_file"
  done
  _sf_get_values
} # }}}

_sf_s () { # {{{
  orig_ifs=$IFS
  IFS=","
  local tinfo=(${_s_inputs[$_s_current_n]})
  IFS=$orig_ifs
  local origin_name_short=${tinfo[1]}
  local trash_name_short=${tinfo[2]}
  _sf_echo "$(_sf_nth $_s_current_n) trash:
  Original file    : $origin_name_short
  File in trash box: $trash_name_short"
} # }}}

_sf_h () { # {{{
  here=1
  _sf_quit
} # }}}

_sf_execute () { # {{{
  orig_ifs=$IFS
  IFS=","
  local tinfo=(${_s_inputs[$_s_current_n]})
  IFS=$orig_ifs
  local origin_name_short=${tinfo[1]}
  local trash_name_short=${tinfo[2]}
  local origin_name=$(sh -c "echo $origin_name_short") # Expand ~
  local trash_name=$(sh -c "echo $trash_name_short") # Expand ~
  local target="$origin_name"
  if [ $here -eq 1 ];then
    target="$(basename $origin_name)"
  fi
  if [ $confirm -eq 1 ];then
    if [ -e "$target" ];then
      _sf_yn "$target exists. Do you want to overwrite from trash box?"
      local ret=$?
      if [ $ret -ne 0 ];then
        return 0
      fi
    fi
  fi
  if [ $here -eq 1 ];then
    echo Copying ${origine_name} from ${trash_name_short}
    cp -r "$trash_name" "$target"
  else
    echo Brin ${origine_name} back from ${trash_name_short}
    mv -r "$trash_name" "$target"
  fi
} # }}}

# Check arguments
if [ "$#" -lt 1 ];then
  echo "No file/directory is given." 1>&2;
  echo "$HELP" 1>&2;
  exit 1
fi

# Set rm flags
if [ $force -eq 1 ];then
  rmflag="-f"
else
  rmflag="-i"
fi
if [ $rdir -eq 1 ];then
  rmflag="$rmflag -r"
fi

# Set today's trash box
tboxtoday="$mytbox/`date +%Y%m%d`"
if [ ! -d "$tboxtoday" ];then
  mkdir -p "$tboxtoday"
fi

# Iterate on arguments
while [ "$#" -gt 0 ];do
  if [ ! -e "$1" ];then
    echo $1: No such file or directory
    if [ $force -ne 1 ];then
      exit 1
    fi
    shift
    continue
  fi
  trash_size=`du -ms "${1}" |awk '{print $1}'`
  if [ ${trash_size} -gt ${maxsize} ];then
    echo $1 is larger than $maxsize MB, then I delete it directly
    rm $rmflag "$1"
    shift
    continue
  fi

  if [ -d "$1" ] && [ $rdir -ne 1 ];then
    echo $1: is a directory, use "-r" for directory
    shift
    continue
  fi

  if [ $confirm -eq 1 ];then
    echo -n "remove ${1}? "
    read yes
    if ! [[ "$yes" =~ ^[yY] ]];then
      shift
      continue
    fi
  fi

  origin_name=`echo $(cd "$(dirname "$1")";pwd -P)/$(basename "$1")`
  name=`echo $1 | sed -e "s|/$||" | sed -e "s|.*/||"`
  trash_head="${tboxtoday}/${name}"
  trash_name="${trash_head}"
  i=1
  while true;do
    if [ -e "${trash_name}" ];then
      trash_name="${trash_head}.${i}"
      i=`expr ${i} + 1`
    else
      break
    fi
  done

  mv "$origin_name" "$trash_name"
  origin_name_short="${origin_name/#$HOME/~}"
  trash_name_short="${trash_name/#$HOME/~}"
  echo $origin_name_short was moved to $trash_name_short
  mv "$tlist" "$tlist.bak"
  echo "`date +%Y%m%d-%H:%M`,$origin_name_short,$trash_name_short" > "$tlist"
  cat "$tlist.bak" >> "$tlist"
  rm -f "$tlist.bak"
  shift
done
